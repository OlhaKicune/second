<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <link rel="stylesheet" href="ansv.css">
    <title>Document</title>
</head>
<body>
<div>1
        В чём отличие конкатенации от сложения?
  <p>Конкатенация чаще всего используется для соединения значений переменных друг с другом, или строк со строками</p>
  <p> let title = "We wish " + "to be friends";</p>   
  <h2>Не могу ответить на этот вопрос ..... мне наверно очень нужны дополнительные занятия , так как я не понимаю совсем ...Хоть и читаю!</h2>  
</div>

<div>2
Опишите три основных правила именования переменных.
<strong>Общие имена для временных переменных:  i, j, k, m
Общие имена для числовых переменных:  n
Общие имена для символьных переменных:  c, d, e</strong>
<p>Правило 1.</p>

Никакого транслита. Только английский.</strong>
<p>Правило 2.

</p>
<p><strong>Использовать короткие имена только для переменных «местного значения»- например a, e, p,если они используются в небольшом фрагменте кода .</strong></p>
<p>Правило 3.</p>

       <strong> Переменные из нескольких слов пишутся вместеВотТак-borderLeftWidth</strong>

</div>


<div>3
В чем отличие == от ===?
<h3>Равенство ==</h3>
        Для сравнения двух величин в JS присутствует оператор равенства ==, он возвращает true если значения равны и false в обратном случае. Перед сравнением значения будут приведены к одному типу.
<p> 10== 10 // true</p>
<p>3 == '3' // true</p>
<p>2 == 3   // false</p>
<p>2 == '3' // false</p>
<h3> Строгое равенство === и строгое неравенство !==  </h3>Преобразования операндов в сравнениях могут привести к неожиданным и ненужным результатам. Предположим нас не устраивает ситуация что число 3 и строка '3' равны. В таком случае необходимо использовать строгое равенство.
Строгое равенство не выполняет преобразование и сначала сравнивает тип переменных, и в случае не совпадения сразу же возвращает false.
<p>10 === 10  // true</p>
<p>3 === '3'  // false</p>
<p>2 === 3    // false</p>
<p>2 === '3'  // false</p>
Оператор строго неравенства работает аналогичным образом.</div>

<div>4
Объясните причины использования методов parseInt(), parseFloat(), Number()
<p>parseFloat и parseInt преобразуют в число максимальную соответствующую подстроку, с начала строки, отбросив предварительно пробельные символы.</p>
<p> <h3>Number </h3>- целую строку, так же отбросив предварительно пробельные символы.
        Если аргумент не может быть преобразован в число, возвращается NaN.

</p>
<p><h3> parseFloat()</h3> принимает строку в качестве аргумента и возвращает десятичное число (число с плавающей точкой)
        parseFloat - это высокоуровневая функция, не привязанная ни к одному объекту.

        parseFloat разбирает текстовую строку, ищет и возвращает из нее десятичное число. Если функция встретит знак, отличный от (+ или -), цифр(0-9), разделительной точки, или показателя степени, она вернет значение, предшествующее этому знаку, игнорируя все последующие символы . Допускаются позади и впереди идущие пробелы.
        
        Если первый символ нельзя привести к числовому виду, parseFloat вернет NaN.</p>
        <p>Функция <h3>parseInt() </h3>принимает строку в качестве аргумента и возвращает целое число в соответствии с указанным основанием системы счисления.</p>

</div>

<div>5
Зачем использовать битовые операции?
</div><div style="padding-top:22.000%;position:relative;"><iframe src="https://gifer.com/embed/470B" width="100px" height="100px" style='position:absolute;top:0;left:0;' frameBorder="0" allowFullScreen></iframe></div><p><a href="https://gifer.com"></a></p>

<div>6
Постройте таблицу приоритетов математических операторов.
<p>console.log(3 + 4 * 5); // 3 + 20......(приоритет *)</p>
<p>console.log(4 * 3 ** 2); // 4 * 9.....(приоритет **)</p>
<p>console.log(a = b = 5)....... (= одинаковый приоритет)</p>
</div>

<div>7
Как использовать методы String, Number, Boolean?

<p><h3>Строковый приметив</h3></p>

      <p> let s1 = '2 + 2';             // создаёт строковый примитив</p>
      <p> let s2 = new String('2 + 2'); // создаёт объект String</p>
      <p>  console.log(eval(s1));        // выведет число 4</p>
      <p> console.log(eval(s2));        // выведет строку '2 + 2'</p>

      <p><h3>Number</h3></p>
      <p>new Number(value);</p>
        <p> let a = new Number('123'); // a === 123 is false</p>
                <p>let b = Number('123'); // b === 123 is true</p>
                        <p>a instanceof Number; // is true</p>
                                <p>b instanceof Number; // is false</p>
        <p><h3>Boolean</h3>Логическое значение.</p>
        <p>Любой объект, чьё значение не является равным undefined или null, включая сам объект Boolean со значением, равным false, вычисляется в true при передаче его в условное выражение. Например, условие в следующей инструкции if вычисляется в true:</p>
        <p>Let x = new Boolean(false);</p>
        <p>        if (x) {
                  // этот код будет выполнен
                }</p> 
</div>
</body>
</html>